// Copyright 2024, rcelyte
// SPDX-License-Identifier: BSL-1.0

#include "solarxr_device.h"
#include "ipc.h"

// workaround for a name collision in header generated by FlatCC
#define solarxr_protocol_rpc_SaveFileNotification_file_extension                                                       \
	solarxr_protocol_rpc_SaveFileNotification_file_extension
#include "solarxr_protocol.h"

#include "math/m_relation_history.h"
#include "math/m_vec3.h"
#include "os/os_threading.h"
#include "os/os_time.h"
#include "util/u_debug.h"
#include "util/u_device.h"

#include "xrt/xrt_config_build.h" // TODO: drop `#ifdef XRT_FEATURE_OPENXR_BODY_TRACKING_FULL_BODY_META` guards once !2206 is merged

#include <stdio.h>
#include <stdatomic.h>
#include <wchar.h>

#define BodyPart_COUNT 25 // must be kept in sync with schema
#define MAX_GENERIC_TRACKERS 32
typedef uint32_t solarxr_trackerid_t;

DEBUG_GET_ONCE_LOG_OPTION(solarxr_log, "SOLARXR_LOG", U_LOGGING_WARN)
DEBUG_GET_ONCE_BOOL_OPTION(solarxr_raw_trackers, "SOLARXR_RAW_TRACKERS", false)
DEBUG_GET_ONCE_NUM_OPTION(solarxr_sync_delay_ms, "SOLARXR_SYNC_DELAY_MS", 4)
DEBUG_GET_ONCE_NUM_OPTION(solarxr_sync_timeout_ms, "SOLARXR_SYNC_TIMEOUT_MS", 50)

struct solarxr_device;
struct solarxr_generic_tracker
{
	struct xrt_device base;
	struct m_relation_history *history;
	struct solarxr_device *parent;
	struct solarxr_generic_tracker **weak_ref;
};

struct solarxr_device
{
	struct xrt_device base;
	struct xrt_device *hmd; // this reference will be dangling in `solarxr_device_destroy()`
	struct os_thread thread;
	struct IpcSocket socket, feedback;
	_Atomic(int64_t) next_sync;
	struct os_mutex mutex;
	int64_t timestamp;
	struct solarxr_device_bone
	{
		struct xrt_pose pose;
		float length;
	} bones[BodyPart_COUNT];
	solarxr_trackerid_t trackerIds[MAX_GENERIC_TRACKERS];
	struct solarxr_generic_tracker *trackers[MAX_GENERIC_TRACKERS];
	uint32_t generation;
	uint32_t poll_packet_len;
	uint8_t poll_packet[];
};

static inline struct solarxr_device *
solarxr_device(struct xrt_device *const xdev)
{
	return (struct solarxr_device *)xdev;
}

static inline struct solarxr_generic_tracker *
solarxr_generic_tracker(struct xrt_device *const xdev)
{
	return (struct solarxr_generic_tracker *)xdev;
}

static void
solarxr_device_get_tracked_pose(struct xrt_device *const xdev,
                                const enum xrt_input_name name,
                                const int64_t at_timestamp_ns,
                                struct xrt_space_relation *const out_relation)
{
	struct xrt_device *const hmd = solarxr_device(xdev)->hmd;
	if (hmd != NULL) {
		xrt_device_get_tracked_pose(hmd, name, at_timestamp_ns, out_relation);
	} else {
		*out_relation = (struct xrt_space_relation){0};
	}
}

static xrt_result_t
solarxr_device_update_inputs(struct xrt_device *const xdev)
{ // TODO: needed?
	struct solarxr_device *const device = solarxr_device(xdev);
	os_mutex_lock(&device->mutex);
	for (uint32_t i = 0; i < device->base.input_count; ++i) {
		device->base.inputs[i].timestamp = device->timestamp;
	}
	for (uint32_t i = 0; i < ARRAY_SIZE(device->trackers); ++i) {
		if (device->trackers[i] != NULL) {
			device->trackers[i]->base.inputs[0].timestamp = device->timestamp;
		}
	}
	os_mutex_unlock(&device->mutex);
	return XRT_SUCCESS;
}

// TODO: this needs to be called for cases where SlimeVR *itself* uses tracking (i.e. autobone calibration), not just when OpenXR apps are running
static void
solarxr_device_sync(struct solarxr_device *const device)
{
	const int64_t time = os_monotonic_get_ns(), next_sync = atomic_exchange(&device->next_sync, INT64_MAX);
	if (time <= next_sync) {
		atomic_store(&device->next_sync, next_sync);
		return;
	}
	struct xrt_space_relation head = {0};
	solarxr_device_get_tracked_pose(&device->base, XRT_INPUT_GENERIC_HEAD_POSE, time, &head);
	if (head.relation_flags == 0) {
		atomic_store(&device->next_sync, next_sync);
		return;
	}

	IpcSocket_send(&device->socket, device->poll_packet, device->poll_packet_len);
	atomic_store(&device->next_sync, time + debug_get_num_option_solarxr_sync_timeout_ms() * U_TIME_1MS_IN_NS);

	struct {
		uint8_t _1; uint8_t length; uint8_t _2; float x; uint8_t _3; float y; uint8_t _4; float z; uint8_t _5;
		float qx; uint8_t _6; float qy; uint8_t _7; float qz; uint8_t _8; float qw; uint8_t _9; uint8_t data_source;
	}  __attribute__((packed)) pkt_position = {
		(1 << 3) | 2, sizeof(pkt_position) - 2,
		(2 << 3) | 5, head.pose.position.x,
		(3 << 3) | 5, head.pose.position.y,
		(4 << 3) | 5, head.pose.position.z,
		(5 << 3) | 5, head.pose.orientation.x,
		(6 << 3) | 5, head.pose.orientation.y,
		(7 << 3) | 5, head.pose.orientation.z,
		(8 << 3) | 5, head.pose.orientation.w,
		(9 << 3) | 0, 0x03,
	};
	IpcSocket_send(&device->feedback, (uint8_t*)&pkt_position, sizeof(pkt_position));
}

static inline struct xrt_body_skeleton_joint_fb
offset_joint(const struct xrt_body_skeleton_joint_fb parent, const int32_t name, const struct xrt_vec3 offset)
{
	return (struct xrt_body_skeleton_joint_fb){
	    .pose =
	        {
	            .orientation = parent.pose.orientation,
	            .position = m_vec3_add(parent.pose.position, offset),
	        },
	    .joint = name,
	    .parent_joint = parent.joint,
	};
}

static xrt_result_t
solarxr_device_get_body_skeleton(struct xrt_device *const xdev,
                                 const enum xrt_input_name body_tracking_type,
                                 struct xrt_body_skeleton *const out_value)
{
	struct xrt_body_skeleton_joint_fb *joints;
	uint32_t joint_count;
	int32_t none;
	switch (body_tracking_type) {
	case XRT_INPUT_FB_BODY_TRACKING: {
		joints = out_value->body_skeleton_fb.joints;
		joint_count = ARRAY_SIZE(out_value->body_skeleton_fb.joints);
		none = XRT_BODY_JOINT_NONE_FB;
		break;
	}
#ifdef XRT_FEATURE_OPENXR_BODY_TRACKING_FULL_BODY_META
	case XRT_INPUT_META_FULL_BODY_TRACKING: {
		joints = out_value->full_body_skeleton_meta.joints;
		joint_count = ARRAY_SIZE(out_value->full_body_skeleton_meta.joints);
		none = XRT_FULL_BODY_JOINT_NONE_META;
		break;
	}
#endif
	default: return XRT_ERROR_NOT_IMPLEMENTED;
	}

	struct solarxr_device *const device = solarxr_device(xdev);
	for (uint32_t i = 0; i < joint_count; ++i) {
		joints[i] = (struct xrt_body_skeleton_joint_fb){XRT_POSE_IDENTITY, none, none};
	}

	// The spec doesn't define a particular layout for these joints beyond simply "a T-pose", so...
	// clang-format off
	joints[0] = (struct xrt_body_skeleton_joint_fb){XRT_POSE_IDENTITY, XRT_BODY_JOINT_HEAD_FB, XRT_BODY_JOINT_ROOT_FB};
	joints[1] = offset_joint(joints[0], XRT_BODY_JOINT_NECK_FB, (struct xrt_vec3){0.f, -device->bones[solarxr_protocol_datatypes_BodyPart_NECK].length, 0.f});
	joints[2] = offset_joint(joints[1], XRT_BODY_JOINT_CHEST_FB, (struct xrt_vec3){0.f, -device->bones[solarxr_protocol_datatypes_BodyPart_UPPER_CHEST].length, 0.f});
	joints[3] = offset_joint(joints[2], XRT_BODY_JOINT_SPINE_UPPER_FB, (struct xrt_vec3){0.f, -device->bones[solarxr_protocol_datatypes_BodyPart_CHEST].length, 0.f});
	joints[4] = offset_joint(joints[3], XRT_BODY_JOINT_SPINE_LOWER_FB, (struct xrt_vec3){0.f, -device->bones[solarxr_protocol_datatypes_BodyPart_WAIST].length, 0.f});
	joints[5] = offset_joint(joints[4], XRT_BODY_JOINT_HIPS_FB, (struct xrt_vec3){0.f, -device->bones[solarxr_protocol_datatypes_BodyPart_HIP].length, 0.f});
	joints[6] = offset_joint(joints[1], XRT_BODY_JOINT_LEFT_SHOULDER_FB, (struct xrt_vec3){-device->bones[solarxr_protocol_datatypes_BodyPart_LEFT_SHOULDER].length, 0.f, 0.f});
	joints[7] = offset_joint(joints[1], XRT_BODY_JOINT_RIGHT_SHOULDER_FB, (struct xrt_vec3){device->bones[solarxr_protocol_datatypes_BodyPart_RIGHT_SHOULDER].length, 0.f, 0.f});
	joints[8] = offset_joint(joints[6], XRT_BODY_JOINT_LEFT_ARM_UPPER_FB, (struct xrt_vec3){-device->bones[solarxr_protocol_datatypes_BodyPart_LEFT_UPPER_ARM].length, 0.f, 0.f});
	joints[9] = offset_joint(joints[7], XRT_BODY_JOINT_RIGHT_ARM_UPPER_FB, (struct xrt_vec3){device->bones[solarxr_protocol_datatypes_BodyPart_RIGHT_UPPER_ARM].length, 0.f, 0.f});
	joints[10] = offset_joint(joints[8], XRT_BODY_JOINT_LEFT_ARM_LOWER_FB, (struct xrt_vec3){-device->bones[solarxr_protocol_datatypes_BodyPart_LEFT_LOWER_ARM].length, 0.f, 0.f});
	joints[11] = offset_joint(joints[9], XRT_BODY_JOINT_RIGHT_ARM_LOWER_FB, (struct xrt_vec3){device->bones[solarxr_protocol_datatypes_BodyPart_RIGHT_LOWER_ARM].length, 0.f, 0.f});
	joints[12] = offset_joint(joints[10], XRT_BODY_JOINT_LEFT_HAND_WRIST_FB, (struct xrt_vec3){-device->bones[solarxr_protocol_datatypes_BodyPart_LEFT_HAND].length, 0.f, 0.f});
	joints[13] = offset_joint(joints[11], XRT_BODY_JOINT_RIGHT_HAND_WRIST_FB, (struct xrt_vec3){device->bones[solarxr_protocol_datatypes_BodyPart_RIGHT_HAND].length, 0.f, 0.f});
#ifdef XRT_FEATURE_OPENXR_BODY_TRACKING_FULL_BODY_META
	if (body_tracking_type != XRT_INPUT_META_FULL_BODY_TRACKING) {
		return XRT_SUCCESS;
	}
	joints[14] = offset_joint(joints[5], XRT_FULL_BODY_JOINT_LEFT_UPPER_LEG_META, (struct xrt_vec3){0.f, -device->bones[solarxr_protocol_datatypes_BodyPart_LEFT_UPPER_LEG].length, 0.f});
	joints[15] = offset_joint(joints[5], XRT_FULL_BODY_JOINT_RIGHT_UPPER_LEG_META, (struct xrt_vec3){0.f, -device->bones[solarxr_protocol_datatypes_BodyPart_RIGHT_UPPER_LEG].length, 0.f});
	joints[16] = offset_joint(joints[14], XRT_FULL_BODY_JOINT_LEFT_LOWER_LEG_META, (struct xrt_vec3){0.f, -device->bones[solarxr_protocol_datatypes_BodyPart_LEFT_LOWER_LEG].length, 0.f});
	joints[17] = offset_joint(joints[15], XRT_FULL_BODY_JOINT_RIGHT_LOWER_LEG_META, (struct xrt_vec3){0.f, -device->bones[solarxr_protocol_datatypes_BodyPart_RIGHT_LOWER_LEG].length, 0.f});
	joints[18] = offset_joint(joints[16], XRT_FULL_BODY_JOINT_LEFT_FOOT_TRANSVERSE_META, (struct xrt_vec3){0.f, 0.f, -device->bones[solarxr_protocol_datatypes_BodyPart_LEFT_FOOT].length});
	joints[19] = offset_joint(joints[17], XRT_FULL_BODY_JOINT_RIGHT_FOOT_TRANSVERSE_META, (struct xrt_vec3){0.f, 0.f, -device->bones[solarxr_protocol_datatypes_BodyPart_RIGHT_FOOT].length});
#endif
	// clang-format on
	return XRT_SUCCESS;
}

static xrt_result_t
solarxr_device_get_body_joints(struct xrt_device *const xdev,
                               const enum xrt_input_name body_tracking_type,
                               const int64_t desired_timestamp_ns,
                               struct xrt_body_joint_set *const out_value)
{
	static const uint32_t jointMap[BodyPart_COUNT] = {
	    [solarxr_protocol_datatypes_BodyPart_HEAD] = XRT_BODY_JOINT_HEAD_FB,
	    [solarxr_protocol_datatypes_BodyPart_NECK] = XRT_BODY_JOINT_NECK_FB,
	    [solarxr_protocol_datatypes_BodyPart_CHEST] = XRT_BODY_JOINT_SPINE_UPPER_FB,
	    [solarxr_protocol_datatypes_BodyPart_WAIST] = XRT_BODY_JOINT_SPINE_LOWER_FB,
	    [solarxr_protocol_datatypes_BodyPart_HIP] = XRT_BODY_JOINT_HIPS_FB,
#ifdef XRT_FEATURE_OPENXR_BODY_TRACKING_FULL_BODY_META
	    [solarxr_protocol_datatypes_BodyPart_LEFT_UPPER_LEG] = XRT_FULL_BODY_JOINT_LEFT_UPPER_LEG_META,
	    [solarxr_protocol_datatypes_BodyPart_RIGHT_UPPER_LEG] = XRT_FULL_BODY_JOINT_RIGHT_UPPER_LEG_META,
	    [solarxr_protocol_datatypes_BodyPart_LEFT_LOWER_LEG] = XRT_FULL_BODY_JOINT_LEFT_LOWER_LEG_META,
	    [solarxr_protocol_datatypes_BodyPart_RIGHT_LOWER_LEG] = XRT_FULL_BODY_JOINT_RIGHT_LOWER_LEG_META,
	    [solarxr_protocol_datatypes_BodyPart_LEFT_FOOT] = XRT_FULL_BODY_JOINT_LEFT_FOOT_TRANSVERSE_META,
	    [solarxr_protocol_datatypes_BodyPart_RIGHT_FOOT] = XRT_FULL_BODY_JOINT_RIGHT_FOOT_TRANSVERSE_META,
#endif
	    [solarxr_protocol_datatypes_BodyPart_LEFT_LOWER_ARM] = XRT_BODY_JOINT_LEFT_ARM_LOWER_FB,
	    [solarxr_protocol_datatypes_BodyPart_RIGHT_LOWER_ARM] = XRT_BODY_JOINT_RIGHT_ARM_LOWER_FB,
	    [solarxr_protocol_datatypes_BodyPart_LEFT_UPPER_ARM] = XRT_BODY_JOINT_LEFT_ARM_UPPER_FB,
	    [solarxr_protocol_datatypes_BodyPart_RIGHT_UPPER_ARM] = XRT_BODY_JOINT_RIGHT_ARM_UPPER_FB,
	    [solarxr_protocol_datatypes_BodyPart_LEFT_HAND] = XRT_BODY_JOINT_LEFT_HAND_WRIST_FB,
	    [solarxr_protocol_datatypes_BodyPart_RIGHT_HAND] = XRT_BODY_JOINT_RIGHT_HAND_WRIST_FB,
	    [solarxr_protocol_datatypes_BodyPart_LEFT_SHOULDER] = XRT_BODY_JOINT_LEFT_SHOULDER_FB,
	    [solarxr_protocol_datatypes_BodyPart_RIGHT_SHOULDER] = XRT_BODY_JOINT_RIGHT_SHOULDER_FB,
	    [solarxr_protocol_datatypes_BodyPart_UPPER_CHEST] = XRT_BODY_JOINT_CHEST_FB,
	    // LEFT_HIP
	    // RIGHT_HIP
	};
	struct xrt_body_joint_location_fb *joints;
	uint32_t joint_count;
	switch (body_tracking_type) {
	case XRT_INPUT_FB_BODY_TRACKING: {
		joints = out_value->body_joint_set_fb.joint_locations;
		joint_count = ARRAY_SIZE(out_value->body_joint_set_fb.joint_locations);
		break;
	}
#ifdef XRT_FEATURE_OPENXR_BODY_TRACKING_FULL_BODY_META
	case XRT_INPUT_META_FULL_BODY_TRACKING: {
		joints = out_value->full_body_joint_set_meta.joint_locations;
		joint_count = ARRAY_SIZE(out_value->full_body_joint_set_meta.joint_locations);
		break;
	}
#endif
	default: return XRT_ERROR_NOT_IMPLEMENTED;
	}

	struct solarxr_device *const device = solarxr_device(xdev);
	solarxr_device_sync(device);

	os_mutex_lock(&device->mutex);
	out_value->base_body_joint_set_meta.sample_time_ns = device->timestamp;
	out_value->base_body_joint_set_meta.confidence = 1.f; // N/A
	out_value->base_body_joint_set_meta.skeleton_changed_count = device->generation;
	out_value->base_body_joint_set_meta.is_active = true;
	for (uint32_t i = 0; i < joint_count; ++i) {
		joints[i].relation = (struct xrt_space_relation)XRT_SPACE_RELATION_ZERO;
	}
	for (solarxr_protocol_datatypes_BodyPart_enum_t part = 0; part < ARRAY_SIZE(device->bones); ++part) {
		const struct xrt_pose pose = device->bones[part].pose;
		const uint32_t index = jointMap[part];
		if (index == 0 || index >= joint_count ||
		    memcmp(&pose.orientation, &(struct xrt_quat){0}, sizeof(struct xrt_quat)) == 0) {
			continue;
		}
		joints[index].relation = (struct xrt_space_relation){
		    .relation_flags = XRT_SPACE_RELATION_ORIENTATION_VALID_BIT | XRT_SPACE_RELATION_POSITION_VALID_BIT |
		                      XRT_SPACE_RELATION_ORIENTATION_TRACKED_BIT |
		                      XRT_SPACE_RELATION_POSITION_TRACKED_BIT,
		    .pose = pose,
		};
	}
	out_value->body_pose = (struct xrt_space_relation){
	    .relation_flags = XRT_SPACE_RELATION_ORIENTATION_VALID_BIT | XRT_SPACE_RELATION_POSITION_VALID_BIT |
	                      XRT_SPACE_RELATION_ORIENTATION_TRACKED_BIT | XRT_SPACE_RELATION_POSITION_TRACKED_BIT,
	    .pose = XRT_POSE_IDENTITY,
	};
	os_mutex_unlock(&device->mutex);
	return XRT_SUCCESS;
}

static inline struct xrt_quat
convert_quat(const solarxr_protocol_datatypes_math_Quat_struct_t quat)
{
	return (struct xrt_quat){
	    .x = solarxr_protocol_datatypes_math_Quat_x_get(quat),
	    .y = solarxr_protocol_datatypes_math_Quat_y_get(quat),
	    .z = solarxr_protocol_datatypes_math_Quat_z_get(quat),
	    .w = solarxr_protocol_datatypes_math_Quat_w_get(quat),
	};
}

static inline struct xrt_vec3
convert_vec3(const solarxr_protocol_datatypes_math_Vec3f_struct_t vec)
{
	return (struct xrt_vec3){
	    .x = solarxr_protocol_datatypes_math_Vec3f_x_get(vec),
	    .y = solarxr_protocol_datatypes_math_Vec3f_y_get(vec),
	    .z = solarxr_protocol_datatypes_math_Vec3f_z_get(vec),
	};
}

static void
solarxr_device_handle_trackers(struct solarxr_device *const device,
                               const solarxr_protocol_data_feed_tracker_TrackerData_vec_t trackers)
{
	for (uint32_t j = 0, trackers_len = solarxr_protocol_data_feed_tracker_TrackerData_vec_len(trackers);
	     j < trackers_len; ++j) {
		const solarxr_protocol_data_feed_tracker_TrackerData_table_t trackerData =
		    solarxr_protocol_data_feed_tracker_TrackerData_vec_at(trackers, j);
		const solarxr_protocol_datatypes_TrackerId_table_t idTable =
		    solarxr_protocol_data_feed_tracker_TrackerData_tracker_id_get(trackerData);
		const solarxr_trackerid_t id = solarxr_protocol_datatypes_TrackerId_tracker_num_get(idTable) |
		                               (solarxr_protocol_datatypes_TrackerId_device_id_is_present(idTable)
		                                    ? (uint32_t)solarxr_protocol_datatypes_DeviceId_id_get(
		                                          solarxr_protocol_datatypes_TrackerId_device_id_get(idTable))
		                                          << 8
		                                    : 0xffffff00u);
		static_assert(sizeof(wchar_t) == sizeof(id), "Invalid datatype for `wmemchr()`");
		const solarxr_trackerid_t *const match = (const solarxr_trackerid_t *)wmemchr(
		    (const wchar_t *)device->trackerIds, (wchar_t)id, ARRAY_SIZE(device->trackerIds));
		if (match == NULL) {
			continue;
		}
		struct solarxr_generic_tracker *const tracker = device->trackers[match - device->trackerIds];
		if (tracker == NULL) {
			continue;
		}
		struct xrt_space_relation relation = {.pose.orientation.w = 1};
		if (solarxr_protocol_data_feed_tracker_TrackerData_rotation_is_present(trackerData)) {
			const solarxr_protocol_datatypes_math_Quat_struct_t rotation =
			    solarxr_protocol_data_feed_tracker_TrackerData_rotation_get(trackerData);
			relation.relation_flags |=
			    XRT_SPACE_RELATION_ORIENTATION_VALID_BIT | XRT_SPACE_RELATION_ORIENTATION_TRACKED_BIT;
			relation.pose.orientation = convert_quat(rotation);
		}
		if (solarxr_protocol_data_feed_tracker_TrackerData_position_is_present(trackerData)) {
			relation.relation_flags |=
			    XRT_SPACE_RELATION_POSITION_VALID_BIT | XRT_SPACE_RELATION_POSITION_TRACKED_BIT;
			relation.pose.position =
			    convert_vec3(solarxr_protocol_data_feed_tracker_TrackerData_position_get(trackerData));
		}
		if (solarxr_protocol_data_feed_tracker_TrackerData_raw_angular_velocity_is_present(trackerData)) {
			relation.relation_flags |= XRT_SPACE_RELATION_ANGULAR_VELOCITY_VALID_BIT;
			relation.angular_velocity = convert_vec3(
			    solarxr_protocol_data_feed_tracker_TrackerData_raw_angular_velocity_get(trackerData));
		}
		if (solarxr_protocol_data_feed_tracker_TrackerData_linear_acceleration_is_present(trackerData)) {
			relation.relation_flags |= XRT_SPACE_RELATION_LINEAR_VELOCITY_VALID_BIT;
			relation.linear_velocity = convert_vec3(
			    solarxr_protocol_data_feed_tracker_TrackerData_linear_acceleration_get(trackerData));
		}
		if (relation.relation_flags != 0) {
			m_relation_history_push(tracker->history, &relation, device->socket.timestamp);
		}
	}
}

static solarxr_protocol_MessageBundle_table_t
IpcSocket_receive_bundle(struct IpcSocket *const socket, const bool exit_on_error)
{
	do {
		const uint32_t buffer_len = IpcSocket_receive(socket);
		if (buffer_len == 0) {
			continue;
		}
		if (solarxr_protocol_MessageBundle_verify_as_root(socket->buffer, buffer_len) == 0) {
			return solarxr_protocol_MessageBundle_as_root(socket->buffer);
		}
		U_LOG_IFL_E(socket->log_level, "solarxr_protocol_MessageBundle_verify_as_root() failed");
		if (exit_on_error) {
			return NULL;
		}
	} while (IpcSocket_wait(socket));
	if (exit_on_error) {
		U_LOG_IFL_E(socket->log_level, "IpcSocket_receive() failed");
	}
	return NULL;
}

static void *
solarxr_network_thread(void *const ptr)
{
	struct solarxr_device *const device = (struct solarxr_device *)ptr;
	for (solarxr_protocol_MessageBundle_table_t bundle;
	     (bundle = IpcSocket_receive_bundle(&device->socket, false)) != NULL;) {
		const solarxr_protocol_data_feed_DataFeedMessageHeader_vec_t feeds =
		    solarxr_protocol_MessageBundle_data_feed_msgs_get(bundle);
		if (feeds == NULL) {
			continue;
		}
#if 0 // for latency testing
		U_LOG_IFL_W(device->socket.log_level, "%.3fus", ((int64_t)os_monotonic_get_ns() - (atomic_load(&device->next_sync) - debug_get_num_option_solarxr_sync_timeout_ms() * U_TIME_1MS_IN_NS)) / 1000.);
#endif
		atomic_store(&device->next_sync,
		             device->timestamp + debug_get_num_option_solarxr_sync_delay_ms() * U_TIME_1MS_IN_NS);
		const size_t feeds_len = solarxr_protocol_data_feed_DataFeedMessageHeader_vec_len(feeds);
		solarxr_protocol_data_feed_device_data_DeviceData_vec_t devices = NULL;
		solarxr_protocol_data_feed_tracker_TrackerData_vec_t synthetic = NULL;
		solarxr_protocol_data_feed_Bone_vec_t bones = NULL;
		for (size_t i = 0; i < feeds_len; ++i) {
			const solarxr_protocol_data_feed_DataFeedMessageHeader_table_t header =
			    solarxr_protocol_data_feed_DataFeedMessageHeader_vec_at(feeds, i);
			if (solarxr_protocol_data_feed_DataFeedMessageHeader_message_type_get(header) !=
			    solarxr_protocol_data_feed_DataFeedMessage_DataFeedUpdate) {
				continue;
			}
			solarxr_protocol_data_feed_DataFeedUpdate_table_t update =
			    solarxr_protocol_data_feed_DataFeedMessageHeader_message_get(header);
			bones = solarxr_protocol_data_feed_DataFeedUpdate_bones_get(update);
			if (debug_get_bool_option_solarxr_raw_trackers()) {
				devices = solarxr_protocol_data_feed_DataFeedUpdate_devices_get(update);
			} else {
				synthetic = solarxr_protocol_data_feed_DataFeedUpdate_synthetic_trackers_get(update);
			}
		}
		os_mutex_lock(&device->mutex);
		uint32_t i = 0, devices_len = 0;
		if (synthetic != NULL) {
			solarxr_device_handle_trackers(device, synthetic);
		} else if (devices != NULL) {
			for (devices_len = (uint32_t)solarxr_protocol_data_feed_device_data_DeviceData_vec_len(devices);
			     i < devices_len; ++i) {
				const solarxr_protocol_data_feed_device_data_DeviceData_table_t deviceData =
				    solarxr_protocol_data_feed_device_data_DeviceData_vec_at(devices, i);
				if (solarxr_protocol_data_feed_device_data_DeviceData_trackers_is_present(deviceData)) {
					solarxr_device_handle_trackers(
					    device,
					    solarxr_protocol_data_feed_device_data_DeviceData_trackers_get(deviceData));
				}
			}
		}
		if (bones != NULL) {
			const size_t bones_len = solarxr_protocol_data_feed_Bone_vec_len(bones);
			device->timestamp = device->socket.timestamp;
			struct solarxr_device_bone newBones[ARRAY_SIZE(device->bones)] = {0};
			for (size_t i = 0; i < bones_len; ++i) {
				const solarxr_protocol_data_feed_Bone_table_t bone =
				    solarxr_protocol_data_feed_Bone_vec_at(bones, i);
				const solarxr_protocol_datatypes_BodyPart_enum_t part =
				    solarxr_protocol_data_feed_Bone_body_part_get(bone);
				if (part >= ARRAY_SIZE(device->bones)) {
					static bool _once = false;
					if (!_once) {
						_once = true;
						U_LOG_IFL_W(device->socket.log_level,
						            "Unexpected SolarXR BodyPart %hhu", part);
					}
					continue;
				}
				newBones[part].pose = (struct xrt_pose){
				    .orientation = convert_quat(solarxr_protocol_data_feed_Bone_rotation_g_get(bone)),
				    .position = convert_vec3(solarxr_protocol_data_feed_Bone_head_position_g_get(bone)),
				};
				newBones[part].length = solarxr_protocol_data_feed_Bone_bone_length_get(bone);
			}
			for (uint32_t i = 0; i < ARRAY_SIZE(device->bones); ++i) {
				if (memcmp(&newBones[i].length, &device->bones[i].length, sizeof(newBones[i].length)) ==
				    0) {
					continue;
				}
				++device->generation;
				break;
			}
			memcpy(device->bones, newBones, sizeof(device->bones));
		}
		os_mutex_unlock(&device->mutex);
	}
	return NULL;
}

static void
solarxr_device_destroy(struct xrt_device *xdev)
{
	struct solarxr_device *const device = solarxr_device(xdev);
	IpcSocket_destroy(&device->feedback);
	IpcSocket_destroy(&device->socket);
	if (!pthread_equal(device->thread.thread, pthread_self())) {
		os_thread_join(&device->thread);
	}
	for (uint32_t i = 0; i < ARRAY_SIZE(device->trackers); ++i) {
		if (device->trackers[i] == NULL) {
			continue;
		}
		device->trackers[i]->weak_ref = NULL;
		device->trackers[i]->parent = NULL;
	}
	os_mutex_destroy(&device->mutex);
	u_device_free(&device->base);
}

static void
solarxr_generic_tracker_get_tracked_pose(struct xrt_device *const xdev,
                                         const enum xrt_input_name name,
                                         const int64_t at_timestamp_ns,
                                         struct xrt_space_relation *const out_relation)
{
	struct solarxr_generic_tracker *const device = solarxr_generic_tracker(xdev);
	solarxr_device_sync(device->parent);
	m_relation_history_get(device->history, at_timestamp_ns, out_relation);
}

static void
solarxr_generic_tracker_destroy(struct xrt_device *const xdev)
{
	struct solarxr_generic_tracker *const device = solarxr_generic_tracker(xdev);
	if (device->weak_ref != NULL) {
		os_mutex_lock(&device->parent->mutex);
		*device->weak_ref = NULL;
		os_mutex_unlock(&device->parent->mutex);
	}
	m_relation_history_destroy(&device->history);
	u_device_free(&device->base);
}

uint32_t
solarxr_device_create_xdevs(struct xrt_device *const hmd, struct xrt_device **const out_xdevs, uint32_t out_xdevs_cap)
{
	if (out_xdevs_cap == 0) {
		return 0;
	}
	if (out_xdevs_cap - 1 > MAX_GENERIC_TRACKERS) {
		out_xdevs_cap = 1 + MAX_GENERIC_TRACKERS;
	}
	flatcc_builder_t builder;
	int result = flatcc_builder_init(&builder);
	result = result || flatbuffers_buffer_start(&builder, solarxr_protocol_MessageBundle_file_identifier);
	result = result || solarxr_protocol_MessageBundle_start(&builder);
	result = result || solarxr_protocol_data_feed_DataFeedMessageHeader_start(&builder);
	result = result || solarxr_protocol_data_feed_PollDataFeed_start(&builder);
	result = result || solarxr_protocol_data_feed_DataFeedConfig_start(&builder);
	if (out_xdevs_cap >= 2) {
		result = result || solarxr_protocol_data_feed_tracker_TrackerDataMask_start(&builder);
		result = result || solarxr_protocol_data_feed_tracker_TrackerDataMask_rotation_add(&builder, true);
		result = result || solarxr_protocol_data_feed_tracker_TrackerDataMask_position_add(&builder, true);
		result = result ||
		         solarxr_protocol_data_feed_tracker_TrackerDataMask_raw_angular_velocity_add(&builder, true);
		result = result ||
		         solarxr_protocol_data_feed_tracker_TrackerDataMask_linear_acceleration_add(&builder, true);
		const solarxr_protocol_data_feed_tracker_TrackerDataMask_ref_t trackerDataMask =
		    solarxr_protocol_data_feed_tracker_TrackerDataMask_end(&builder);
		if (debug_get_bool_option_solarxr_raw_trackers()) {
			result = result || solarxr_protocol_data_feed_device_data_DeviceDataMask_start(&builder);
			result = result || solarxr_protocol_data_feed_device_data_DeviceDataMask_tracker_data_add(
			                       &builder, trackerDataMask);
			result = result ||
			         solarxr_protocol_data_feed_DataFeedConfig_data_mask_add(
			             &builder, solarxr_protocol_data_feed_device_data_DeviceDataMask_end(&builder));
		} else {
			result = result || solarxr_protocol_data_feed_DataFeedConfig_synthetic_trackers_mask_add(
			                       &builder, trackerDataMask);
		}
	}
	result = result || solarxr_protocol_data_feed_DataFeedConfig_bone_mask_add(&builder, true);
	result = result || solarxr_protocol_data_feed_PollDataFeed_config_add(
	                       &builder, solarxr_protocol_data_feed_DataFeedConfig_end(&builder));
	result = result || solarxr_protocol_data_feed_DataFeedMessageHeader_message_add_value(
	                       &builder, solarxr_protocol_data_feed_DataFeedMessage_as_PollDataFeed(
	                                     solarxr_protocol_data_feed_PollDataFeed_end(&builder)));
	result = result || solarxr_protocol_data_feed_DataFeedMessageHeader_message_add_type(
	                       &builder, solarxr_protocol_data_feed_DataFeedMessage_PollDataFeed);
	result = result || solarxr_protocol_MessageBundle_data_feed_msgs_add(
	                       &builder, solarxr_protocol_data_feed_DataFeedMessageHeader_vec_create(
	                                     &builder,
	                                     (solarxr_protocol_data_feed_DataFeedMessageHeader_ref_t[1]){
	                                         solarxr_protocol_data_feed_DataFeedMessageHeader_end(&builder),
	                                     },
	                                     1));
	result = result || !flatbuffers_buffer_end(&builder, solarxr_protocol_MessageBundle_end(&builder));
	assert(result == 0);
	size_t poll_packet_len = 0;
	uint8_t *const poll_packet = flatcc_builder_get_direct_buffer(&builder, &poll_packet_len);

#ifdef XRT_FEATURE_OPENXR_BODY_TRACKING_FULL_BODY_META
	struct solarxr_device *const device =
	    u_device_allocate(U_DEVICE_ALLOC_NO_FLAGS, sizeof(struct solarxr_device) + poll_packet_len, 2, 0);
#else
	struct solarxr_device *const device =
	    u_device_allocate(U_DEVICE_ALLOC_NO_FLAGS, sizeof(struct solarxr_device) + poll_packet_len, 1, 0);
#endif
	device->base.name = XRT_DEVICE_FB_BODY_TRACKING;
	device->base.device_type = XRT_DEVICE_TYPE_BODY_TRACKER;
	strncpy(device->base.str, "SolarXR IpcSockets Connection", sizeof(device->base.str) - 1);
	strncpy(device->base.serial, "ws://localhost:21110", sizeof(device->base.serial) - 1);
	device->base.tracking_origin = hmd->tracking_origin;
	device->base.body_tracking_supported = true;
	device->base.update_inputs = solarxr_device_update_inputs;
	device->base.get_tracked_pose = solarxr_device_get_tracked_pose;
	device->base.get_body_skeleton = solarxr_device_get_body_skeleton;
	device->base.get_body_joints = solarxr_device_get_body_joints;
	device->base.destroy = solarxr_device_destroy;
	device->base.inputs[0].name = XRT_INPUT_FB_BODY_TRACKING;
#ifdef XRT_FEATURE_OPENXR_BODY_TRACKING_FULL_BODY_META
	device->base.inputs[1].name = XRT_INPUT_META_FULL_BODY_TRACKING;
#endif
	device->hmd = hmd;
	device->thread.thread = pthread_self();
	os_mutex_init(&device->mutex);
	memset(device->trackerIds, 0xff, sizeof(device->trackerIds));
	device->poll_packet_len = poll_packet_len;
	memcpy(device->poll_packet, poll_packet, poll_packet_len);

	// bitwise `&` ensures both structs get initialized before any calls to `solarxr_device_destroy()`
	if (((unsigned)IpcSocket_init(&device->socket, debug_get_log_option_solarxr_log()) & (unsigned)IpcSocket_init(&device->feedback, debug_get_log_option_solarxr_log())) == 0) {
		solarxr_device_destroy(&device->base);
		return 0;
	}
	if (!IpcSocket_connect(&device->socket, "SlimeVRRpc", "slimevr/SlimeVRRpc") || !IpcSocket_connect(&device->feedback, "SlimeVRInput", "slimevr/SlimeVRInput")) {
		solarxr_device_destroy(&device->base);
		return 0;
	}
	if (out_xdevs_cap >= 2) {
		result = flatcc_builder_reset(&builder);
		result = result || flatbuffers_buffer_start(&builder, solarxr_protocol_MessageBundle_file_identifier);
		result = result || solarxr_protocol_MessageBundle_start(&builder);
		result = result || solarxr_protocol_data_feed_DataFeedMessageHeader_start(&builder);
		result = result || solarxr_protocol_data_feed_PollDataFeed_start(&builder);
		result = result || solarxr_protocol_data_feed_DataFeedConfig_start(&builder);
		result = result || solarxr_protocol_data_feed_tracker_TrackerDataMask_start(&builder);
		result = result || solarxr_protocol_data_feed_tracker_TrackerDataMask_info_add(&builder, true);
		const solarxr_protocol_data_feed_tracker_TrackerDataMask_ref_t trackerDataMask =
		    solarxr_protocol_data_feed_tracker_TrackerDataMask_end(&builder);
		if (debug_get_bool_option_solarxr_raw_trackers()) {
			result = result || solarxr_protocol_data_feed_device_data_DeviceDataMask_start(&builder);
			result = result || solarxr_protocol_data_feed_device_data_DeviceDataMask_tracker_data_add(
			                       &builder, trackerDataMask);
			result = result ||
			         solarxr_protocol_data_feed_DataFeedConfig_data_mask_add(
			             &builder, solarxr_protocol_data_feed_device_data_DeviceDataMask_end(&builder));
		} else {
			result = result || solarxr_protocol_data_feed_DataFeedConfig_synthetic_trackers_mask_add(
			                       &builder, trackerDataMask);
		}
		result = result || solarxr_protocol_data_feed_PollDataFeed_config_add(
		                       &builder, solarxr_protocol_data_feed_DataFeedConfig_end(&builder));
		result = result || solarxr_protocol_data_feed_DataFeedMessageHeader_message_add_value(
		                       &builder, solarxr_protocol_data_feed_DataFeedMessage_as_PollDataFeed(
		                                     solarxr_protocol_data_feed_PollDataFeed_end(&builder)));
		result = result || solarxr_protocol_data_feed_DataFeedMessageHeader_message_add_type(
		                       &builder, solarxr_protocol_data_feed_DataFeedMessage_PollDataFeed);
		result = result || solarxr_protocol_MessageBundle_data_feed_msgs_add(
		                       &builder, solarxr_protocol_data_feed_DataFeedMessageHeader_vec_create(
		                                     &builder,
		                                     (solarxr_protocol_data_feed_DataFeedMessageHeader_ref_t[1]){
		                                         solarxr_protocol_data_feed_DataFeedMessageHeader_end(&builder),
		                                     },
		                                     1));
		result = result || !flatbuffers_buffer_end(&builder, solarxr_protocol_MessageBundle_end(&builder));
		assert(result == 0);
		size_t packet_len = 0;
		uint8_t *const packet = flatcc_builder_get_direct_buffer(&builder, &packet_len);
		result = IpcSocket_send(&device->socket, packet, (uint32_t)packet_len);
		if (!result) {
			U_LOG_IFL_E(device->socket.log_level, "IpcSocket_send() failed");
			solarxr_device_destroy(&device->base);
			return 0;
		}
		flatcc_builder_clear(&builder);
		const solarxr_protocol_MessageBundle_table_t bundle = IpcSocket_receive_bundle(&device->socket, true);
		if (bundle == NULL) {
			solarxr_device_destroy(&device->base);
			return 0;
		}
		const solarxr_protocol_data_feed_DataFeedMessageHeader_vec_t feeds =
		    solarxr_protocol_MessageBundle_data_feed_msgs_get(bundle);
		if (feeds == NULL) {
			U_LOG_IFL_E(device->socket.log_level, "Missing data feed");
			solarxr_device_destroy(&device->base);
			return 0;
		}
		if (solarxr_protocol_data_feed_DataFeedMessageHeader_vec_len(feeds) != 1) {
			U_LOG_IFL_E(device->socket.log_level, "Unexpected data feed count");
			solarxr_device_destroy(&device->base);
			return 0;
		}
		const solarxr_protocol_data_feed_DataFeedMessageHeader_table_t header =
		    solarxr_protocol_data_feed_DataFeedMessageHeader_vec_at(feeds, 0);
		if (solarxr_protocol_data_feed_DataFeedMessageHeader_message_type_get(header) !=
		    solarxr_protocol_data_feed_DataFeedMessage_DataFeedUpdate) {
			U_LOG_IFL_E(device->socket.log_level, "Unexpected data feed message type");
			solarxr_device_destroy(&device->base);
			return 0;
		}
		solarxr_protocol_data_feed_DataFeedUpdate_table_t update =
		    solarxr_protocol_data_feed_DataFeedMessageHeader_message_get(header);
		uint32_t tracker_descs_len = 0;
		solarxr_protocol_data_feed_tracker_TrackerData_table_t tracker_descs[ARRAY_SIZE(device->trackers)];
		if (debug_get_bool_option_solarxr_raw_trackers()) {
			const solarxr_protocol_data_feed_device_data_DeviceData_vec_t devices =
			    solarxr_protocol_data_feed_DataFeedUpdate_devices_get(update);
			if (devices != NULL) {
				const uint32_t devices_len =
				    (uint32_t)solarxr_protocol_data_feed_device_data_DeviceData_vec_len(devices);
				for (uint32_t i = 0; i < devices_len; ++i) {
					const solarxr_protocol_data_feed_device_data_DeviceData_table_t deviceData =
					    solarxr_protocol_data_feed_device_data_DeviceData_vec_at(devices, i);
					const solarxr_protocol_data_feed_tracker_TrackerData_vec_t trackers =
					    solarxr_protocol_data_feed_device_data_DeviceData_trackers_get(deviceData);
					if (trackers == NULL) {
						continue;
					}
					for (uint32_t i = 0, trackers_len =
					                         solarxr_protocol_data_feed_tracker_TrackerData_vec_len(
					                             trackers);
					     i < trackers_len && tracker_descs_len < ARRAY_SIZE(tracker_descs); ++i) {
						tracker_descs[tracker_descs_len++] =
						    solarxr_protocol_data_feed_tracker_TrackerData_vec_at(trackers, i);
					}
				}
			}
		} else {
			const solarxr_protocol_data_feed_tracker_TrackerData_vec_t trackers =
			    solarxr_protocol_data_feed_DataFeedUpdate_synthetic_trackers_get(update);
			if (trackers != NULL) {
				for (uint32_t i = 0,
				              trackers_len =
				                  solarxr_protocol_data_feed_tracker_TrackerData_vec_len(trackers);
				     i < trackers_len && tracker_descs_len < ARRAY_SIZE(tracker_descs); ++i) {
					tracker_descs[tracker_descs_len++] =
					    solarxr_protocol_data_feed_tracker_TrackerData_vec_at(trackers, i);
				}
			}
		}
		if (tracker_descs_len > out_xdevs_cap - 1) {
			tracker_descs_len = out_xdevs_cap - 1;
		}
		for (uint32_t i = 0; i < tracker_descs_len; ++i) {
			const solarxr_protocol_datatypes_TrackerId_table_t idTable =
			    solarxr_protocol_data_feed_tracker_TrackerData_tracker_id_get(tracker_descs[i]);
			const solarxr_trackerid_t id =
			    solarxr_protocol_datatypes_TrackerId_tracker_num_get(idTable) |
			    (solarxr_protocol_datatypes_TrackerId_device_id_is_present(idTable)
			         ? (uint32_t)solarxr_protocol_datatypes_DeviceId_id_get(
			               solarxr_protocol_datatypes_TrackerId_device_id_get(idTable))
			               << 8
			         : 0xffffff00u);

			struct solarxr_generic_tracker *const tracker =
			    U_DEVICE_ALLOCATE(struct solarxr_generic_tracker, U_DEVICE_ALLOC_NO_FLAGS, 1, 0);
			tracker->base.name = XRT_DEVICE_VIVE_TRACKER; // TODO: use different name here?
			tracker->base.device_type = XRT_DEVICE_TYPE_GENERIC_TRACKER;
			snprintf(tracker->base.str, sizeof(tracker->base.str), "SolarXR Tracker %04x", id);
			snprintf(tracker->base.serial, sizeof(tracker->base.serial), "%04x", id);
			tracker->base.tracking_origin = hmd->tracking_origin;
			tracker->base.orientation_tracking_supported = true;
			tracker->base.position_tracking_supported = true;
			tracker->base.update_inputs = u_device_noop_update_inputs;
			tracker->base.get_tracked_pose = solarxr_generic_tracker_get_tracked_pose;
			tracker->base.destroy = solarxr_generic_tracker_destroy;
			tracker->base.inputs[0].name = XRT_INPUT_GENERIC_TRACKER_POSE;
			m_relation_history_create(&tracker->history);
			tracker->parent = device;
			tracker->weak_ref = &device->trackers[i];
			device->trackers[i] = tracker;
			device->trackerIds[i] = id;

			const solarxr_protocol_data_feed_tracker_TrackerInfo_table_t info =
			    solarxr_protocol_data_feed_tracker_TrackerData_info_get(tracker_descs[i]);
			if (info == NULL ||
			    !solarxr_protocol_data_feed_tracker_TrackerInfo_display_name_is_present(info)) {
				continue;
			}
			snprintf(tracker->base.str, sizeof(tracker->base.str), "SolarXR Tracker \"%s\"",
			         solarxr_protocol_data_feed_tracker_TrackerInfo_display_name_get(info));
		}
	} else {
		flatcc_builder_clear(&builder);
	}
	if (os_thread_start(&device->thread, solarxr_network_thread, device) != 0) {
		U_LOG_IFL_E(device->socket.log_level, "pthread_create() failed");
		for (uint32_t i = 0; i < ARRAY_SIZE(device->trackers); ++i) {
			if (device->trackers[i] != NULL) {
				solarxr_generic_tracker_destroy(&device->trackers[i]->base);
			}
		}
		solarxr_device_destroy(&device->base);
		return 0;
	}
	IpcSocket_send(&device->feedback, (uint8_t[28]){
		(3 << 3) | 2, 26, // TrackerAdded
		(2 << 3) | 2, 10, 'M', 'o', 'n', 'a', 'd', 'o', ' ', 'H', 'M', 'D', // tracker_serial = "Monado HMD"
		(3 << 3) | 2, 10, 'M', 'o', 'n', 'a', 'd', 'o', ' ', 'H', 'M', 'D', // tracker_name = "Monado HMD"
		(4 << 3) | 0, 19, // tracker_role = HMD
	}, 28);
	IpcSocket_send(&device->feedback, (uint8_t[4]){
		(4 << 3) | 2, 2, // TrackerStatus
		(2 << 3) | 0, 1, // status = OK
	}, 4);
	// early sync to initialize bone lengths needed by `solarxr_device_get_body_skeleton()`
	solarxr_device_sync(device);
	uint32_t trackerCount = 0;
	out_xdevs[trackerCount++] = &device->base;
	for (uint32_t i = 0; i < ARRAY_SIZE(device->trackers); ++i) {
		if (device->trackers[i] == NULL) {
			continue;
		}
		assert(trackerCount < out_xdevs_cap);
		out_xdevs[trackerCount++] = &device->trackers[i]->base;
	}
	return trackerCount;
}
